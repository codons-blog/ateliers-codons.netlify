{
  "hash": "766bb32b0b9f07d1c5850a519ea9f137",
  "result": {
    "markdown": "---\ntitle: \"Introduction au Tidyverse\"\nsubtitle: \"Utiliser le Tidyverse pour manipuler des données\"\nauthor:\n  - Sandra Angers-Blondin\n  - Jonathan Kitt (adaptation)\ndate: \"2022-10-24\"\ndraft: false\ncategories: [R, RStudio, Tidyverse]\nformat: \n  html: \n    toc: true\n    toc-depth: 2\n    toc-title: \"Sommaire\"\n---\n\n\n\n\n*Ce tutoriel est adapté de [Basic data manipulation](https://ourcodingclub.github.io/tutorials/data-manip-intro/index.html) et [Efficient data manipulation](https://ourcodingclub.github.io/tutorials/data-manip-efficient/) du site [Our Coding Club](https://ourcodingclub.github.io/).*\n\n<br>\n\n# Introduction\n\n## Qu'est-ce que le Tidyverse ?\n\nLe [Tidyverse](https://www.tidyverse.org/) est un ensemble de packages proposant de multiples fonctions utiles à l'ensemble des étapes d'une analyse :\n\n|                                               |                                       |\n|:--------------------------------------|:--------------------------------|\n| [readr](https://readr.tidyverse.org/)         | importer et exporter les données      |\n| [tibble](https://tibble.tidyverse.org/)       | format de tableau propre au tidyverse |\n| [dplyr](https://dplyr.tidyverse.org/)         | manipuler les données                 |\n| [tidyr](https://tidyr.tidyverse.org/)         | transformer des tableaux              |\n| [stringr](https://stringr.tidyverse.org/)     | manipuler des chaînes de caractères   |\n| [forcats](https://forcats.tidyverse.org/)     | manipuler des variables catégorielles |\n| [ggplot2](https://ggplot2.tidyverse.org/)     | représenter les données               |\n| [purrr](https://purrr.tidyverse.org/)         | programmation fonctionnelle           |\n| [lubridate](https://lubridate.tidyverse.org/) | manipuler des dates                   |\n\n<br>\n\n## Pré-requis\n\nSi vous n'avez pas suivi les autres tutoriels, vous pouvez [créer un projet RStudio](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/#créer-un-projet) et [une arborescence](https://ateliers-codons.netlify.app/posts/02-premiers-pas-avec-r/#créer-une-arborescence).\n\nPour utiliser le Tidyverse, vous pouvez soit installer et charger séparément les packages dont vous aurez besoin, soit installer et charger directement la suite complète :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Installer et charger les packages readr et dplyr\ninstall.packages(c(\"readr\", \"dplyr\"))\nlibrary(readr)\nlibrary(dplyr)\n\n# Installer et charger la suite Tidyverse\ninstall.packages(\"tidyverse\")\nlibrary(tidyverse)\n```\n:::\n\n\n::: {.callout-caution icon=\"true\"}\n## Les conflits\n\nLorsque vous exécutez la fonction `library(tidyverse)`, le message suivant s'affiche dans la console :\n\n![](img/tidyverse_intro_01.png)\n\nR vous indique :\n\n-   le nom et la version des packages individuels (*Attaching packages*)\\\n-   les fonctions portant des noms identiques existant dans d'autres packages (*Conflicts*)\n\nIl existe par exemple une fonction `filter()` dans le package `stats`. Si vous souhaitez utiliser cette dernière fonction plutôt que celle proposée dans le package `dplyr`, il vous foudra préciser le package en question : `stats::filter()`.\n:::\n\n<br>\n\n# Premiers pas dans le Tidyverse\n\nLes fonctions proposées dans les différents packages de la suite Tidyverse sont - en règle générale - nommées d'après les actions qu'elles accomplissent, ce qui rend leur mémorisation plus simple et leur utilisation plus intuitive.\n\n## Importer les données\n\nNous allons utiliser le même jeu de données que dans les tutoriels précédents (vous pouvez le télécharger [ici](https://raw.githubusercontent.com/codons-blog/ateliers-codons.netlify/main/raw/pingouins.csv) et le sauvegarder dans votre dossier `raw/`).\n\nPour importer les données, nous utilisons la fonction `read_csv()`, à ne pas comprendre avec la fonction `read.csv()` utilisée précédemment.\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins <- readr::read_csv(file = \"raw/pingouins.csv\")\n```\n:::\n\n\nVous pouvez voir dans la console des informations concernant vos données :\\\n- les *dimensions* du tableau\\\n- le *séparateur* de colonnes\\\n- les *types* et les *noms* des variables\n\n<br>\n\nTapez `pingouins` dans la console et appuyez sur `Entrée` : vos données s'affichent et vous pouvez voir qu'il s'agit d'un *tibble*, qui présente quelques particularités par rapport à un tableau \"classique\" :\n\n-   les dimensions du *tibble* sont précisées\\\n-   les *types* des variables sont indiquées sous les noms des colonnes\\\n-   seules les *dix premières lignes* sont affichées\\\n-   le nombre de colonnes affichées dépend de la largeur de l'écran\\\n-   les noms de colonnes sont raccourcis si nécessaire\\\n-   les données manquantes *NA* sont mises en évidence\n\nPour bien voir la différence entre un `tibble` et un `data.frame`, comparez les deux commandes suivantes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins\nas.data.frame(pingouins)\n```\n:::\n\n\n<br>\n\n::: {.callout-tip icon=\"true\"}\n\n## Exporter des données\n\nPour exporter des données au format *csv*, utiliser la fonction `write_csv()`\n\n:::\n\n<br>\n\n## Explorer les données\n\nPlusieurs fonctions incluses dans R permettent d'explorer rapidement des données pour s'assurer qu'elles ont été correctement importées :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Afficher les premieres lignes\nhead(pingouins)\n\n# Afficher les dernieres lignes\ntail(pingouins)\n\n# Afficher la structure des donnees\nstr(pingouins)\n```\n:::\n\n\nLa fonction `glimpse()` (du package `readr`) retourne sensiblement les mêmes informations que la fonction `str()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::glimpse(pingouins)\n```\n:::\n\n\n<br>\n\n## Créer une copie de travail\n\nLa première chose à faire avant de manipuler, modifier et transformer nos données est de créer une copie de travail : cela nous permettra, en cas d'erreur, de repartir des données d'origines.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins\n```\n:::\n\n\n<br>\n\n## Renommer des colonnes\n\nCommençons par renommer des colonnes afin de respecter les conventions d'écriture :\n\n-   *snake_case* : caractères minuscules, mots séparés par des `_`\\\n-   *camelCase* : aucune séparation entre les mots, majuscule pour débuter un mot\n\nLa fonction `rename` s'utilise de la façon suivante : `rename(data, nouveau nom = ancien nom)`\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::rename(pingouins_tmp, ile = Ile)\n```\n:::\n\n\nNous pourrions procéder de la même façon pour plusieurs colonnes à la fois :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::rename(pingouins_tmp, espece = Espece, ile = Ile)\n```\n:::\n\n\n<br>\n\nLe package [`janitor`](https://cran.r-project.org/web/packages/janitor/vignettes/janitor.html) est dédié au nettoyage d'un tableau (noms de colonnes, suppression des doublons, ...). Utilisons la fonction `clean_names()` de ce package :\n\n\n::: {.cell}\n\n```{.r .cell-code}\njanitor::clean_names(pingouins_tmp)\n```\n:::\n\n\nAssignons ces noms de colonnes nettoyés à notre copie de travail :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- janitor::clean_names(pingouins_tmp)\n```\n:::\n\n\nAssurons-nous que les noms de colonnes ont bien été modifiés :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnames(pingouins_tmp)\n```\n:::\n\n\n<br>\n\n::: {.callout-tip icon=\"true\"}\n## Explorer les arguments d'une fonction\n\nPour afficher l'aide de la fonction `clean_names`, tapez `?clean_names` (ou `?janitor::clean_names`) dans la console. Vous trouverez dans l'aide toutes les informations concernant une fonction. Dans notre cas, nous pourrions utiliser différentes conventions d'écriture pour nos noms de colonnes : `clean_names(pingouins_tmp, case = \"lower_camel\")` par exemple.\n:::\n\n<br>\n\n## Sélectionner des colonnes\n\nLa fonction `select()` permet de sélectionner les colonnes d'un tableau. Nous allons sélectionner les colonnes *espece*, *ile*, *longueur_bec_mm*, *hauteur_bec_mm*, *longueur_aile_mm* et *masse_corporelle_g*. Nous pouvons procéder de plusieurs façons :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Indiquer toutes les colonnes\ndplyr::select(pingouins_tmp, espece, ile, longueur_bec_mm, hauteur_bec_mm,\n              longueur_aile_mm, masse_corporelle_g)\n\n# Indiquer les suites de colonnes\ndplyr::select(pingouins_tmp, espece:ile, longueur_bec_mm:masse_corporelle_g)\n\n# Supprimer des colonnes\ndplyr::select(pingouins_tmp, -c(etude_numero, echantillon_numero, id_individu))\n```\n:::\n\n\n<br>\n\nD'autres fonctions du package `dplyr` permettent de sélectionner des colonnes :\n\n- `contains()` : sélectionner les noms de colonnes qui contiennent un motif  \n- `starts_width()` : sélectionner les noms de colonnes qui commencent par un motif  \n- `ends_width()` : sélectionner les noms de colonnes qui se terminent par un motif  \n\nDans notre cas, nous pouvons sélectionner les colonnes *espece* et *ile*, puis les colonnes dont le nom se termine par *mm* ou par *g* :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Utiliser la fonction ends_with()\ndplyr::select(pingouins_tmp, espece, ile, dplyr::ends_with(c(\"mm\", \"g\")))\n```\n:::\n\n\nAssignons cette sélection de colonnes à notre objet :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- dplyr::select(pingouins_tmp, espece, ile, dplyr::ends_with(c(\"mm\", \"g\")))\n```\n:::\n\n\n<br>\n\n::: {.callout-tip icon=\"true\"}\n## Renommer et ré-ordonner des colonnes avec `select()`\n\nNous pouvons utiliser la fonction `select()` pour renommer des colonnes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::select(pingouins_tmp, espece:longueur_aile_mm, masse = masse_corporelle_g)\n```\n:::\n\n\nMais aussi pour modifier l'ordre des colonnes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::select(pingouins_tmp, espece:ile, masse_corporelle_g, longueur_bec_mm:longueur_aile_mm)\n```\n:::\n\n\nEnfin, si nous n'avons que quelques colonnes à déplacer, la fonction `everything()` permet de sélectionner le reste du tableau !\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::select(pingouins_tmp, ile, dplyr::everything())\n```\n:::\n\n:::\n\n<br>\n\n## Filtrer des données\n\nLa fonction `filter()` permet de filtrer les données à l'aide d'opérateurs logiques :\n\n|        |                     |\n|--------|---------------------|\n| `==`   | strictement égal à  |\n| `<=`   | inférieur ou égal à |\n| `<`    | inférieur à         |\n| `>=`   | supérieur ou égal à |\n| `>`    | supérieur à         |\n| `!=`   | différent de        |\n| `%in%` | appartient à        |\n| `&`    | et                  |\n| `|`    | ou                  |\n| `!`    | négation            |\n\nVoici deux exemples :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Individus vivant sur l'ile Biscoe pesant au moins 5 kgs\ndplyr::filter(pingouins_tmp, ile == \"Biscoe\", masse_corporelle_g >= 5000)\n\n# Individus vivant sur les iles Biscoe ou Torgersen\ndplyr::filter(pingouins_tmp, ile %in% c(\"Biscoe\", \"Torgersen\"))\n```\n:::\n\n\n<br>\n\nLa fonction `between()` permet de garder les valeurs numériques entre deux bornes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Individus pesant entre 3 kgs et 3,5 kgs\ndplyr::filter(pingouins_tmp, dplyr::between(masse_corporelle_g, 3000, 3250))\n```\n:::\n\n\n<br>\n\nNotre jeu de données contient des données manquantes `NA`. Il existe plusieurs manières de supprimer ces données manquantes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Garder les lignes pour lesquelles la variable longueur_bec_mm ne contient pas de NA\ndplyr::filter(pingouins_tmp, !is.na(longueur_bec_mm))\n\n# Supprimer les lignes pour lesquelles la variable longueur_bec_mm contient au moins un NA\ntidyr::drop_na(pingouins_tmp, longueur_bec_mm)\n\n# Supprimer les lignes contenant des NAs, quelque soit la variable\ntidyr::drop_na(pingouins_tmp)\n```\n:::\n\n\n<br>\n\n::: {.callout-tip icon=\"true\"}\n## Extraire les lignes uniques\n\nLa fonction `distinct()` permet d'extraire les observations uniques présentes dans une colonne ou une combinaison de colonnes : \n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::distinct(pingouins_tmp, ile, espece)\n```\n:::\n\n\n:::\n\n<br>\n\n## Trier des données\n\nLa fonction `arrange()` permet de trier des données. Par défaut, le tri s'effectue par ordre croissant. Pour trier des données par ordre décroissant, il faut ajouter la fonction `desc()` ou utiliser un *moins* `-` devant le nom de la colonne : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Trier les données par ordre croisant de longueur de bec\ndplyr::arrange(pingouins_tmp, longueur_bec_mm)\n\n# Trier les données par ordre décroissant de masse corporelle\ndplyr::arrange(pingouins_tmp, dplyr::desc(masse_corporelle_g))\ndplyr::arrange(pingouins_tmp, -masse_corporelle_g)\n```\n:::\n\n\n<br>\n\nIl est possible de trier sur plusieurs colonnes : nous pouvons trier les individus par ordre décroissant de hauteur de bec puis par ordre décroissant de longueur de bec. Cela peut être utile pour départager des individus \"ex-aequo\" pour une variable :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::arrange(pingouins_tmp, dplyr::desc(hauteur_bec_mm), dplyr::desc(longueur_bec_mm))\n```\n:::\n\n\n<br>\n\n## Créer ou modifier des colonnes\n\nLa fonction `mutate()` permet de créer une nouvelle colonne. Nous pouvons par exemple ajouter une colonne *ratio_bec* dans laquelle nous allons calculer le rapport entre la longueur du bec et sa hauteur :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::mutate(pingouins_tmp, ratio_bec = longueur_bec_mm / hauteur_bec_mm)\n```\n:::\n\n\nNous pouvons également modifier le contenu d'une colonne, par exemple en ajoutant le suffixe *island* au contenu de la colonne *ile* :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::mutate(pingouins_tmp, ile = paste0(ile, \" island\"))\n```\n:::\n\n\nLa fonction `transmute()` permet quant à elle de créer une nouvelle colonne tout en supprimant les colonnes pré-existantes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::transmute(pingouins_tmp, masse_kgs = masse_corporelle_g / 1000)\n```\n:::\n\n\n<br>\n\n## Effectuer des comptages\n\nLa fonction `count()` permet d'effectuer des comptages sur les variables.\n\nComptons le nombre d'individus par espèce :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::count(pingouins_tmp, espece)\n```\n:::\n\n\nL'argument `sort = TRUE` permet d'afficher le résultat par ordre décroissant :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::count(pingouins_tmp, espece, sort = TRUE)\n```\n:::\n\n\n<br>\n\nNous pouvons également compter les individus par île et par espèce :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::count(pingouins_tmp, ile, espece, sort = TRUE)\n```\n:::\n\n\n<br>\n\nDans le dernier cas, seuls les combinaisons de variables pour lesquelles il existe des combinaisons sont affichées. Il peut être intéressant d'afficher tous les cas de figure, à l'aide de la fonction `complete()`. Il faut préciser les variables à utiliser pour compléter les combinaisons : \n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_ind_ile_espece <- dplyr::count(pingouins_tmp, ile, espece, sort = TRUE)\ntidyr::complete(nb_ind_ile_espece, ile, espece)\n```\n:::\n\n\nLa variable `n` prend comme valeur `NA` lorsque la combinaison n'est pas présente dans le tableau. Nous pouvons remplacer ces `NA` par des zéros : \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidyr::complete(nb_ind_ile_espece, ile, espece, fill = list(n = 0))\n```\n:::\n\n\n<br>\n\n\n## Agréger des lignes\n\nLa fonction `summarise()` permet d'agréger des lignes en effectuant une opération.\n\nCalculons la longueur moyenne du bec pour l'ensemble des individus, sans oublier l'argument `na.rm = TRUE` pour supprimer les données manquantes lors du calcul. Si nous avions assigné à l'objet `pingouins_tmp` les données après avoir retiré les lignes contenant des données manquantes, nous pourrions nous passer de cet argument. Dans le doute, mieux vaut ajouter cet argument :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::summarise(pingouins_tmp,\n                 longueur_bec_mm_moy = mean(longueur_bec_mm, na.rm = TRUE))\n```\n:::\n\n\nCette fonction peut également s'utiliser sur plusieurs variables :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::summarise(pingouins_tmp,\n                 longueur_bec_mm_moy = mean(longueur_bec_mm, na.rm = TRUE),\n                 hauteur_bec_mm_moy = mean(hauteur_bec_mm, na.rm = TRUE))\n```\n:::\n\n\n<br>\n\n## Regrouper les données\n\nLa fonction `group_by()`, utilisée en combinaison avec la fonction `summarise()`, permet de regrouper les données pour effectuer des calculs par groupe.\n\nCalculons la longueur moyenne du bec par espece :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::summarise(dplyr::group_by(pingouins_tmp, espece),\n                 longueur_bec_mm_moy = mean(longueur_bec_mm, na.rm = TRUE))\n```\n:::\n\n\nCette fonction permet de définir des sous-groupes. Calculons la longueur moyenne du bec par île et par espèce :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndplyr::summarise(dplyr::group_by(pingouins_tmp, ile, espece),\n                 longueur_bec_mm_moy = mean(longueur_bec_mm, na.rm = TRUE))\n```\n:::\n\n\n::: {.callout-tip icon=\"true\"}\n## Dégrouper les données\n\nLa fonction `ungroup()` permet de dégrouper les données\n:::\n\n<br>\n\n::: {.callout-important icon=\"false\" collapse=\"true\"}\n## Exercice 1 - énoncé\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importer le fichier gapminder.csv\n\n# Explorer les donnees \n\n# Compter le nombre de pays par continent\n\n# Creer une copie de travail\n\n# Nettoyer les noms de colonnes\n\n# Deplacer la colonne \"continent\" en premiere position\n\n# Ajouter une colonne contenant le PIB global\n\n# Filtrer les donnees pour 2007 et trier par ordre decroissant de PIB global\n\n# Calculer la mediane du PIB par habitant en 2007 par continent\n```\n:::\n\n:::\n\n::: {.callout-important icon=\"false\" collapse=\"true\"}\n## Exercice 1 - solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importer le fichier gapminder.csv\ngapminder <- readr::read_csv(\"raw/gapminder.csv\")\n\n# Explorer les donnees \ndplyr::glimpse(gapminder)\n\n# Creer une copie de travail\ngapminder_tmp <- gapminder\n\n# Nettoyer les noms de colonnes\ngapminder_tmp <- janitor::clean_names(gapminder_tmp)\n\n# Deplacer la colonne \"continent\" en premiere position\ngapminder_tmp <- dplyr::select(gapminder_tmp, continent, dplyr::everything())\n\n# Ajouter une colonne contenant le PIB global\ngapminder_tmp <- dplyr::mutate(gapminder_tmp, \n                               gdp_global = pop * gdp_percap)\n\n# Filtrer les donnees pour 2007 et trier par ordre decroissant de PIB global\ngapminder_2007 <- dplyr::filter(gapminder_tmp, year == 2007)\ngapminder_2007_tri <- dplyr::arrange(gapminder_2007, -gdp_global)\n\n# Calculer la mediane du PIB par habitant en 2007 par continent\nsummarise(dplyr::group_by(gapminder_2007, continent),\n          median_gdp_global = median(gdp_percap, na.rm = TRUE))\n```\n:::\n\n:::\n\n<br>\n\n# \"Ceci n'est pas un pipe\"\n\nJusqu'à présent, nous avons utilisé les fonctions une par une, en créant si nécessaire des objets intermédiaires. Cette façon de procéder peut rapidement encombrer notre environnement.\n\nIl existe une façon d'enchaîner les fonctions les unes à la suite des autres, qui présente plusieurs avantages :\n\n-   rendre le code plus clair et lisible\\\n-   réduire le nombre d'objets intermédiaires nécessaires à l'analyse\\\n-   permettre d'utiliser l'auto-complétion (à l'aide de la touche `Tab`)\n\nL'enchaînement des fonctions s'effectue à l'aide de ce que l'on appelle un *pipe*, disponible dans le package [`magrittr`](https://magrittr.tidyverse.org/).\n\n![](img/pipe_logo.png){width=\"20%\"}\n\nUn pipe s'écrit `%>%` et se place à la fin d'une ligne :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins %>%\n  janitor::clean_names()\n```\n:::\n\n\n::: {.callout-tip icon=\"true\"}\n## Raccourci clavier : le pipe\n\nPour insérer un pipe, utilisez la combinaison *Ctrl + Shift + M*\n:::\n\n<br>\n\nNous pouvons ainsi enchaîner les fonctions sans avoir à créer des objets intermédiaires :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins %>%\n  janitor::clean_names() %>%\n  tidyr::drop_na()\n```\n:::\n\n\n<br>\n\n::: {.callout-note icon=\"true\"}\n## Le pipe \"natif\" `|>`\n\nLes versions les plus récentes de R (à partir de 4.1) proposent un pipe \"natif\", qui ne nécessite pas de faire appel au package `magrittr`. Ce pipe s'écrit sous la forme `|>`.\n\nPour utiliser le pipe `|>`, cliquez sur *Tools* \\> *Global Options*. Dans le menu *Code* et l'onglet *Editing*,cochez la case *Use native pipe operator*.\n\n![](img/tidyverse_intro_02.png){width=\"\\\"50%\"}\n\nLe raccourci clavier **Ctrl + Shift + M** insérera alors un pipe `|>`.\n:::\n\n<br>\n\n::: {.callout-important icon=\"false\" collapse=\"true\"}\n## Exercice 2 - énoncé\n\n1. Compter le nombre de pays par continent\n\n2. Effectuer les opérations suivantes à l'aide d'un pipe et les assigner dans un objet `gapminder_tmp`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Creer une copie de travail\n# Nettoyer les noms de colonnes\n# Deplacer la colonne \"continent\" en premiere position\n# Ajouter une colonne contenant le PIB global\n```\n:::\n\n:::\n\n::: {.callout-important icon=\"false\" collapse=\"true\"}\n## Exercice 2 - solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# 1. Compter le nombre de pays par continent\ngapminder %>%\n  dplyr::distinct(Continent, Country) %>%\n  dplyr::count(Continent, sort = TRUE)\n\n# 2. Nettoyer les donnnes\ngapminder_tmp <- gapminder %>%\n  janitor::clean_names() %>%\n  dplyr::select(continent, dplyr::everything()) %>%\n  dplyr::mutate(gdp_global = pop * gdp_percap)\n```\n:::\n\n:::\n\n<br>\n\n# Manipuler des chaînes de caractères\n\nLe package `stringr` est dédié à la manipulation de chaînes de caractères. Nous aimerions séparer la colonne *espece* en deux colonnes :\n\n-   une colonne contenant le nom de l'espèce (*Adelie* par exemple)\\\n-   une colonne contenant le nom latin de l'espèce (*Pygoscelis adeliae*)\n\nLa fonction `str_detect()` permet de rechercher un motif dans une chaîne de caractères :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringr::str_detect(string = pingouins_tmp$espece, pattern = \"Adelie\")\n```\n:::\n\n\n<br>\n\nUtilisons la fonction `word()` pour extraire les mots en position 3 et 4 de la variable espèce. Cette fonction s'utilise de la manière suivante : `str_word(chaine, debut, fin)`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins_tmp %>%\n  dplyr::mutate(nom_latin = stringr::word(string = espece,\n                                          start = 3, end = 4))\n```\n:::\n\n\n<br>\n\nNotre nouvelle variable *nom_latin* a bien été créée, mais elle contient des parenthèses. Pour les supprimer, nous utilisons la fonction `str_remove_all()` en combinaison avec une expression régulière (regex) : les parenthèses à supprimer sont placées entre crochets, eux-mêmes placés entre des guillemets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins_tmp %>%\n  dplyr::mutate(nom_latin = stringr::str_remove_all(string = nom_latin,\n                                                    pattern = \"[()]\"))\n```\n:::\n\n\nIl ne nous reste plus qu'à modifier la variable *espece* afin de ne conserver que le premier mot, puis de modifier l'ordre des colonnes :\n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins_tmp %>%\n  dplyr::mutate(espece = stringr::word(string = espece,\n                                       start = 1, end = 1)) %>%\n  dplyr::select(espece, nom_latin, dplyr::everything())\n```\n:::\n\n\n<br>\n\nExportons maintenant nos données nettoyées à l'aide de la fonction `write_csv()` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwrite_csv(pingouins_tmp, \"data/pingouins_propre.csv\")\n```\n:::\n\n\n<br>\n\n::: {.callout-tip icon=\"true\"}\n## Les expressions régulières\n\nPour en savoir plus sur les expressions régulières, vous pouvez lire [cet article](https://dridk.me/expression-reguliere.html). Il existe souvent plusieurs façons d'arriver au même résultat. Pour le nom latin, nous aurions pu extraire la chaîne de caractères située entre les parenthèses :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringr::str_extract(pingouins$Espece, \"(?<=\\\\().+?(?=\\\\))\")\n```\n:::\n\n\nPour extraire le nom de l'espèce, nous pouvons utiliser une expression régulière pour extraire les caractères précédant le premier espace vide :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstringr::str_extract(pingouins$Espece, \"\\\\w+\")\n```\n:::\n\n:::\n\n<br>\n\n# Joindre des tableaux\n\nLe package `dplyr` propose plusieurs fonctions pour joindre deux tableaux. Les lignes des deux tableaux seront associées en fonction de *clés*, c'est-à-dire des colonnes communes.\n\nLe schéma ci-dessous (tiré du livre [R for Data Science](https://r4ds.had.co.nz/relational-data.html)) représente les différentes fonctions `..._join()` :\n\n![](img/join-venn.png){width=\"50%\"}\n\n<br>\n\nPour bien comprendre ces différentes fonctions, nous allons créer deux sous-ensembles de données :\n\n-   `d1` : lignes 1 à 3 du tableau, variable *longueur_bec_mm*\\\n-   `d2` : lignes 2 à 4 du tableau, variable *hauteur_bec_mm*\n\n<br>\n\nNous commençons par ajouter une colonne contenant les numéros de ligne, à l'aide de la fonction `rowid_to_column()` du package `tibble`. Par défaut, cette fonction ajoute la colonne d'index au début du tableau, et l'argument `var =` permet de choisir le nom de cette colonne. La fonction `slice()` permet de créer un sous-ensemble de lignes à l'aide de leurs positions.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- pingouins_tmp %>%\n  tibble::rowid_to_column(var = \"ind_num\") %>%\n  dplyr::select(ind_num, longueur_bec_mm) %>%\n  dplyr::slice(1:3)\n\nd2 <- pingouins_tmp %>%\n  tibble::rowid_to_column(var = \"ind_num\") %>%\n  dplyr::select(ind_num, hauteur_bec_mm) %>%\n  dplyr::slice(2:4)\n```\n:::\n\n\n|                      |                                       |\n|----------------------|---------------------------------------|\n| `inner_join(d1, d2)` | ![](img/inner_join.png){width=\"50%\"}  |\n| `full_join(d1, d2)`  | ![](img/full_join.png){width=\"50%\"}   |\n| `left_join(d1, d2)`  | ![](img/left_join.png){width=\"50%\"}   |\n| `right_join(d1, d2)` | ![](img/right_join.png){width=\"50%\"}  |\n| `anti_join(d1, d2)`  | ![](img/anti_join_1.png){width=\"50%\"} |\n| `anti_join(d2, d1)`  | ![](img/anti_join_2.png){width=\"50%\"} |\n\n<br>\n\n::: {.callout-tip icon=\"true\"}\n## Les clés de jointure\n\nLa colonne commune porte le même nom dans nos deux tableaux `d1` et `d2`. Si ce n'était pas le cas, nous devrions préciser la *clé* de jointure. Dans ce cas, la colonne de jointure du tableau résultant prendra le nom de cette colonne dans le premier tableau :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd1 <- d1 %>%\n  dplyr::rename(numero_ind = ind_num)\n\ninner_join(d1, d2, by = c(\"numero_ind\" = \"ind_num\"))\n```\n:::\n\n:::\n\n<br>\n\n::: {.callout-important icon=\"false\" collapse=\"true\"}\n## Exercice 3 - énoncé\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importer le fichier codes_pays.csv\n\n# Ajouter les colonnes de ce tableau au tableau gapminder_tmp\n\n# Placer les colonnes \"iso_alpha\" et \"iso_num\" apres la colonne \"country\"\n\n# Exporter ce tableau au format csv\n```\n:::\n\n:::\n\n::: {.callout-important icon=\"false\" collapse=\"true\"}\n## Exercice 3 - solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Importer le fichier codes_pays.csv\ncodes_pays <- readr::read_csv(\"raw/codes_pays.csv\")\n\n# Ajouter les colonnes de ce tableau au tableau gapminder_tmp et deplacer les colonnes\ngapminder_codes <- gapminder_tmp %>%\n  dplyr::left_join(codes_pays) %>%\n  dplyr::select(continent, country, iso_alpha, iso_num, dplyr::everything())\n\n# Exporter ce tableau au format csv\nreadr::write_csv(gapminder_codes, \"data/gapminder_codes.csv\")\n```\n:::\n\n:::\n\n<br>\n\n# Transformer des tableaux\n\nLa suite de packages `tidyverse` se base sur le principe des [*tidy data*](https://www.jstatsoft.org/article/view/v059i10) :\n\n-   chaque variable est située dans sa propre colonne\\\n-   chaque observation est située sur sa propre ligne\\\n-   chaque valeur est située dans sa cellule\n\nCes trois principes sont résumés dans la figure suivante, tirée de [R for Data Science](https://r4ds.had.co.nz/tidy-data.html) :\n\n![](img/tidy-1.png){width=\"75%\"}\n\n<br>\n\nLe package `tidyr` proprose des fonctions permettant de transformer un tableau dans un format *tidy*. Nos données étant déjà dans ce format, nous allons créer un sous-ensemble de données pour les transformer dans un format *non-tidy* puis les transformer à nouveau dans un format *tidy*.\n\nCe sous-ensemble contient les dix premières lignes du tableau et les variables *espece* et *ratio_bec* (nous ajoutons également un index des lignes)\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd3 <- pingouins_tmp %>%\n  tibble::rowid_to_column(var = \"ind_num\") %>%\n  dplyr::select(ind_num, espece, ile, longueur_bec_mm) %>%\n  dplyr::slice(1:10)\n```\n:::\n\n\n<br>\n\nNos données sont dans ce que l'on appelle également un format *long*. Pour les transformer dans un format *non-tidy* ou encore format *large*, nous utilisons la fonction `pivot_wider()`.\n\nLes arguments suivants doivent être précisés :\n\n- `names_from` : colonne qui servira à nommer les colonnes dans le tableau au format large  \n- `values_from` : colonne qui contient les valeurs qui nous intéressent\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidyr::pivot_wider(data = d3,\n                   names_from = ind_num,\n                   values_from = longueur_bec_mm)\n```\n:::\n\n\nUn autre argument, `id_cols`, permet de préciser les colonnes qui permettent d'identifier chaque individu. Par défaut, il s'agit de toutes les colonnes autres que celles précisées dans `names_from` et `values_from`. Dans certains cas, il peut être nécessaire de déclarer explicitement ces colonnes d'identification.\n\n<br>\n\nPour rendre les noms des colonnes plus facilement utilisables et supprimer les \"\\`\\\", nous ajoutons l'argument`names_prefix` :\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidyr::pivot_wider(data = d3,\n                   names_from = ind_num,\n                   names_prefix = \"ind\",\n                   values_from = longueur_bec_mm)\n```\n:::\n\n\nAssignons ce tableau transformé au format *large* dans un objet :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nd3_wide <- tidyr::pivot_wider(data = d3,\n                              names_from = ind_num,\n                              names_prefix = \"ind\",\n                              values_from = longueur_bec_mm)\n```\n:::\n\n\n<br>\n\nLa fonction `pivot_longer()` va nous permettre de revenir dans un format *tidy* (*long*). Nous utilisons les arguments suivants :\n\n- `cols` : colonnes du format large à regrouper  \n- `names_to` : nom de la colonne dans laquelle seront regroupés les noms des colonnes indiqués dans `cols`  \n- `names_prefix` : préfixe à supprimer  \n- `values_to` : nom de la colonne qui contiendra les valeurs  \n\n\n::: {.cell}\n\n```{.r .cell-code}\ntidyr::pivot_longer(data = d3_wide,\n                    cols = -c(espece, ile),\n                    names_to = \"ind_num\",\n                    names_prefix = \"ind\",\n                    values_to = \"longueur_bec_mm\")\n```\n:::\n\n\nLe format *tidy* facilite les analyses en permettant de filtrer les données, de les regrouper, ...\n\n<br>\n\n::: {.callout-important icon=\"false\" collapse=\"true\"}\n## Exercice 4 - énoncé\n\nA partir du tableau `gapminder_tmp` : \n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filtrer les donnees pour les pays d'Europe\n\n# En utilisant la variable \"life_exp\", transformer le tableau au format large\n\n# Transformer ce tableau au format long\n```\n:::\n\n:::\n\n::: {.callout-important icon=\"false\" collapse=\"true\"}\n## Exercice 4 - solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Filtrer les donnees pour les pays d'Europe\neurope <- gapminder_tmp %>%\n  dplyr::filter(continent == \"Europe\")\n\n# En utilisant la variable \"life_exp\", transformer le tableau au format large\neurope_wide <- europe %>%\n  tidyr::pivot_wider(id_cols = c(country, continent),\n                     names_from = year,\n                     names_prefix = \"year\",\n                     values_from = life_exp)\n\n# Transformer ce tableau au format long\neurope_long <- europe_wide %>%\n  tidyr::pivot_longer(cols = -c(country, continent),\n                      names_to = \"year\",\n                      names_prefix = \"year\",\n                      values_to = \"life_exp\")\n```\n:::\n\n:::\n\n<br>\n\n# Manipuler des facteurs\n\nLe package `forcats` propose des fonctions permettant de manipuler des facteurs.\n\nCommençons par transformer les variables qui ont un nombre limité de modalités en facteurs à l'aide de la fonction `fct()`. Par défaut, cette fonction crée des niveaux de facteur selon l'ordre d'apparition des modalités dans le tableau :  \n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins_tmp %>%\n  dplyr::mutate(espece = forcats::fct(espece),\n                nom_latin = forcats::fct(nom_latin),\n                ile = forcats::fct(ile))\n```\n:::\n\n\n<br>\n\nLa fonction `fct_recode()` permet de recoder les niveaux d'un facteur : \n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins_tmp %>%\n  dplyr::mutate(espece = forcats::fct_recode(espece,\n                                             \"espece_Adelie\" = \"Adelie\",\n                                             \"espece_Gentoo\" = \"Gentoo\",\n                                             \"espece_Chinstrap\" = \"Chinstrap\"))\n```\n:::\n\n\n<br>\n\nLa fonction `fct_relevel()` permet d'ordonner manuellement les niveaux d'un facteur : \n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins_tmp %>%\n  dplyr::mutate(ile = forcats::fct_relevel(ile,\n                                           \"Dream\", \"Biscoe\", \"Torgersen\"))\n```\n:::\n\n\n<br>\n\nLa fonction `fct_rev()` permet d'inverser l'ordre des niveaux d'un facteur : \n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins_tmp %>%\n  dplyr::mutate(ile = forcats::fct_rev(ile))\n```\n:::\n\n\n<br>\n\nLa fonction `fct_reorder()` permet de trier les modalités d'un facteur selon une autre variable. Nous pouvons par exemple trier les modalités de la variable *espece* en fonction de la médiane de la variable *hauteur_bec_mm\" : \n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins_tmp %>%\n  dplyr::mutate(espece = forcats::fct_reorder(espece, hauteur_bec_mm, median, na.rm = TRUE))\n```\n:::\n\n\n<br>\n\nLa fonction `fct_infreq()` permet de trier les modalités d'un facteur selon les effectifs (par défaut par ordre décroissant) : \n\n\n::: {.cell}\n\n```{.r .cell-code}\npingouins_tmp <- pingouins_tmp %>%\n  dplyr::mutate(espece = forcats::fct_infreq(espece))\n```\n:::\n\n\n<br>\n\n::: {.callout-tip icon=\"true\"}\n## Intérêt de la gestion des niveaux d'un facteur\n\nLes fonctions du package `forcats` permettent de gérer dynamiquement les niveaux d'un facteur, en fonction de ce que l'on recherche (trier par ordre d'apparition, par effectifs, ...).\nCes fonctions sont particulièrement intéressantes lorsque l'on souhaite représenter graphiquement des variables catégorielles.\n\n:::\n\n<br>\n\n::: {.callout-important icon=\"false\" collapse=\"true\"}\n## Exercice 5 - énoncé\n\nA partir du tableau `gapminder_tmp`\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extraire les donnees pour l'annee 2002\n\n# Transformer les variables \"continent\" et \"country\" en facteurs\n\n# Trier les niveaux la variable \"continent\" par effectif\n\n# Trier les niveaux de la variable \"country\" par population\n```\n:::\n\n:::\n\n::: {.callout-important icon=\"false\" collapse=\"true\"}\n## Exercice 5 - solution\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Extraire les donnees pour l'annee 2002\nyear2002 <- gapminder_tmp %>%\n  dplyr::filter(year == 2002)\n\n# Transformer les variables \"continent\" et \"country\" en facteurs\nyear2002 <- year2002 %>%\n  dplyr::mutate(continent = forcats::fct(continent),\n                country = forcats::fct(country))\n\n# Trier les niveaux la variable \"continent\" par effectif\nyear2002 <- year2002 %>%\n  dplyr::mutate(continent = forcats::fct_infreq(continent))\n\n# Trier les niveaux de la variable \"country\" par population decroissante\nyear2002 <- year2002 %>%\n  dplyr::mutate(country = forcats::fct_reorder(country, -pop))\n```\n:::\n\n:::",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}