{
  "hash": "9a67dd858ccd2882d90e190ccd410419",
  "result": {
    "markdown": "---\ntitle: \"{data.table}\"\nsubtitle: \"Importer, formater et manipuler vos données: {data.table} vs {tidyverse}\"\nauthor:\n  - Pauline Lasserre-Zuber\ndate: \"2023-08-24\"\ncategories: [R, data.table, tidyverse]\nformat: \n  html: \n    toc: true\n    toc-depth: 2\n    self-contained: true\ndraft: false\n---\n\n\n![](img/battle.png)\n\n# Introduction\n\n<br>\n\nPour des tables de données de taille petite et moyenne (inférieure à 1 Go ou moins d'un million d'observations), il est recommandé d'utiliser le package `dplyr`. Pour des tables de données de grande taille (plus de 1 Go ou plus d'un million d'observations), il est recommandé d'utiliser le package `data.table`.\n\nUn des atouts fondamentaux de `data.table` est sa syntaxe compacte qui lui vaut sa rapidité : `data.table` ne manipule que les colonnes mentionnées dans l'opérateur `[…]`, ce qui réduit le temps de traitement des données.\n\nLa forme générale de l'opérateur `[…]` est la suivante :\n\n\n::: {.cell}\n\n```{.r .cell-code}\nDT[i, j, by]\n```\n:::\n\n\nOn part du data.table **DT**, on sélectionne certaines lignes avec **i**, puis on calcule **j** pour chaque groupe défini par **by**. Si on fait un parallèle avec SQL, i correspond au WHERE, j au SELECT et by au GROUP BY. La fonction `[…]` présente deux grands avantages: pas de préfixe DT\\$ pour se référer aux variables à l'intérieur de \\[...\\] et sa concision.\n\nLes fonctions `setDT()` et `as.data.table()` convertissent un data.frame en data.table\n\nLes data.tables sont simplement des data.frames particuliers, donc on peut normalement leur appliquer toutes les méthodes valables pour les data.frames. En particulier, on peut utiliser avec data.table toutes les fonctions des packages habituellement associés à dplyr : stringr pour le maniement de chaînes de caractères, etc.\n\n<br>\n\nSommaire :\n\n**1. [IMPORT DE TABLES FORMAT LONG: readr vs fread](#long)** : [setup](#setup), [import table 1](#table1), [import table 2](#table2), [sélection des données à importer](#col_select), [presentation des données](#presentation)\n\n**2. [CALCULS SUR LES COLONNES](#mean)** : [calculs par groupe selon critères](#mean), [enchainer les calculs](#arrange)\n\n**3. [CREER UNE NOUVELLE COLONNE SELON CRITERES](#mutate)**\n\n**4. [SELECTIONNER DES COLONNES](#select)**: [tydiverse](#tidyverse1), [data.table](#data.table1)\n\n**5. [JOINDRE DES TABLES](#join)**: [Rbase](#Rbase2), [tydiverse](#tidyverse2), [data.table avec ou sans index](#data.table2)\n\n**6. [EXPORTATION DE TABLE](#write)**: [Rbase](#Rbase3), [tydiverse](#tidyverse3), [data.table](#data.table3)\n\n**7. [IMPORT DE TABLE FORMAT LARGE](#wide)**: [tydiverse](#tidyverse4), [data.table](#data.table4)\n\n**8. [FORMATAGE DES DONNEES](#lapply)**: [tydiverse](#tidyverse5), [data.table](#data.table5)\n\n<br>\n\n# 1. Importer des tables au format long : `readr` vs `fread`\n\n## Setup {#setup}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Chargement des packages\nlibrary(readr)\nlibrary(dplyr)\nlibrary(stringr)\n\nlibrary(data.table)\n```\n:::\n\n\nTélécharger les fichiers suivants (en cliquant sur l'icône **Download**) et sauvegardez-les dans votre répertoire de travail :\n\n-   [Fichier 1](https://forgemia.inra.fr/ateliers_codons/data.table/-/blob/main/ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv)\n\n-   [Fichier 2](https://forgemia.inra.fr/ateliers_codons/data.table/-/blob/main/Tae.Chinese_Spring.refSeqv2.1.ISBPs_fasta.txt)\n\n![](img/download.png)\n\n<br>\n\n## Import table 1 {#table1}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# package readr de la suite tidyverse\nstart.time <- Sys.time()\nd <- read_tsv(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\", col_names=T)\ntime.tidy <- Sys.time() - start.time\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n#package data.table\n##info systeme:\nnames(s <- Sys.getenv())\nSys.getenv(\"NUMBER_OF_PROCESSORS\")\nSys.getenv(\"PROCESSOR_LEVEL\")\nSys.getenv(\"OMP_THREAD_LIMIT\")\nSys.setenv(\"OMP_THREAD_LIMIT\"=4)\nSys.getenv(\"OMP_THREAD_LIMIT\")\n\n\n##nThread=1\nsetDTthreads(threads=1, restore_after_fork=TRUE)\ngetDTthreads(verbose = getOption(\"datatable.verbose\"))\n\nstart.time <- Sys.time()\ndt <- fread(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\",\n         nThread=1, sep=\"\\t\", header=TRUE, dec=\".\", encoding = \"UTF-8\", showProgress=TRUE)\ntime.dt1 <- Sys.time() - start.time\ntime.dt1\ntime.tidy\n\n##nThread=4\nsetDTthreads(threads=6, restore_after_fork=TRUE)\ngetDTthreads(verbose = getOption(\"datatable.verbose\"))\n\nstart.time <- Sys.time()\ndt <- fread(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\", \n         nThread=4, sep=\"\\t\", header=TRUE, dec=\".\", encoding = \"UTF-8\", showProgress=TRUE)\ntime.dt4 <- Sys.time() - start.time\ntime.dt4\ntime.tidy\n\n#definition d'un deuxieme seprarteur (sep2) possible !!! :))\n#NB: option stringsAsFactors = TRUE peut ralentir sensiblement l’importation des donnees\n```\n:::\n\n\n<br>\n\n## Import table 2 {#table2}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#package readr de la suite tidyverse\nstart.time <- Sys.time()\nfa <- read_tsv(\"Tae.Chinese_Spring.refSeqv2.1.ISBPs_fasta.txt\", col_names=F)\ntime.tidy <- Sys.time() - start.time\n\ncolnames(fa) <- c(\"read_id\",\"seq\")\n\n#package data.table  ---> nThread \nstart.time <- Sys.time()\nfadt <- fread(\"Tae.Chinese_Spring.refSeqv2.1.ISBPs_fasta.txt\",\n           nThread=4, sep=\"\\t\", colClasses=c(\"character\", \"character\"), header=FALSE,\n           encoding = \"UTF-8\", showProgress=TRUE)\ntime.dt4 <- Sys.time() - start.time\ntime.dt4\ntime.tidy\n```\n:::\n\n\n<br>\n\n## Sélection des données à importer {#col_select}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# #package readr de la suite tidyverse\nstart.time <- Sys.time()\nd <- read_tsv(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\", col_names=T,\n           col_select = -\"query_length\")\ntime.tidy <- Sys.time() - start.time\n\n\n#pour selectionner des colonnes à importer: option \"col_select\" avec ou sans -\n#pour importer une portion de table: option \"skip\" et \"n_max\n\n\n#package data.table\nstart.time <- Sys.time()\ndt <- fread(\"ISBPS_REFSEQV2_vs_RENAN_PSEUDOV2_filtered.bam_summary.tsv\", \n         nThread=4, sep=\"\\t\", header=TRUE, dec=\".\", encoding = \"UTF-8\", showProgress=TRUE,\n         drop=\"query_length\")\ntime.dt4 <- Sys.time() - start.time\ntime.dt4\ntime.tidy\n\n#pour selectionner des colonnes à importer: option \"clo_select\" avec ou sans -\n#pour importer une portion de table: option \"skip\" + \"nrows\"\n```\n:::\n\n\n<br> \\## Presentation des données {#presentation}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#suite tidyverse\nd\nfa\n\ndf <- data.frame(d)\nfadf <- data.frame(fa)\n\n#package data.table\ndt\nfadt\ncolnames(fadt) <- c(\"read_id\",\"seq\")\n\noptions(\"datatable.print.keys\" = TRUE, \"datatable.print.class\" = TRUE)\ndt\n```\n:::\n\n\n<br>\n\n# 2. Calculs sur les colonnes\n\n## Calculs par groupe selon critères {#mean}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# R base\nstart.time <- Sys.time()\nhead(df)\naggregate(df[df[[\"alignemnt_length\"]]==150, \"mapq\"],\n          by=list(df[df[[\"alignemnt_length\"]]==150, \"missmatches\"]),\n          FUN=mean)\nSys.time() - start.time\n\n#suite tidyverse\nstart.time <- Sys.time()\nprint(d %>%\n  dplyr::filter(alignemnt_length==150)%>%\n  dplyr::group_by(missmatches)%>%\n  dplyr::summarise(mean(mapq)),\n  n=100)\nSys.time() - start.time\n\n\n#package data.table\nstart.time <- Sys.time()\ndt[alignemnt_length==150, mean(mapq), by = missmatches]\nSys.time() - start.time\n```\n:::\n\n\n<br> \\## Enchainer les calculs {#arrange}\n\nDplyr utilise l'opérateur pipe %\\>%.\n\nAvec data.table, il suffit d'accoler les opérateurs \\[\\]: dt\\[opération 1\\]\\[opération 2\\]\\[opération 3\\]\\[...\\]\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#suite tidyverse\nprint(d %>%\n        dplyr::filter(alignemnt_length==150) %>%\n        dplyr::group_by(missmatches) %>%\n        dplyr::summarise(mean(mapq))%>%\n        arrange(`mean(mapq)`),\n      n=100)\n\n#package data.table\ndt[alignemnt_length==150, mean(mapq), by = missmatches][order(missmatches)]\n```\n:::\n\n\n<br>\n\n# 3. Créer une nouvelle colonnes selon critères {#mutate}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#suite tidyverse\n##dim ligne --NON-- constante, dim colonne +1 : on cree la colonne nomee \"keep\"\nd_filt=d %>%\n  filter(alignemnt_length==150 & mapq==60)%>%\n  mutate(keep=\"OK\")\nd_filt\n\n##dim ligne constante, dim colonne +1 : on cree la colonne nomee \"keep\"\nstart.time <- Sys.time()\nd=d %>%\n  mutate(keep=if_else(alignemnt_length==150 & mapq==60,\"OK\",\"NA\"))\nSys.time() - start.time\n\nd\n#NB: assignation necessaire\n\n\n#package data.table\n##utilise beaucoup moins de memoire vive\n##la fonction := s’appelle “assignation par reference”, elle peut prendre des arguments entre parentheses`:=`()\n\n##dim ligne --NON-- constante, dim colonne +1\ndt_filt=dt[alignemnt_length==150 & mapq==60][, keep:= \"OK\"]\ndt_filt\n\n##dim ligne constante, dim colonne +1\nstart.time <- Sys.time()\ndt[alignemnt_length==150 & mapq==60, keep:= \"OK\"]\n#NB: pas d'assignation, table modifiee par reference\nSys.time() - start.time\n\ndt[, keep:= \"OK\"][alignemnt_length!=150 | mapq!=60, keep:= NA]\n```\n:::\n\n\n<br>\n\n# 4. Sélectionner des colonnes {#select}\n\n## tidyverse {#tidyverse1}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#suite tidyverse\nd%>%select(read_id, missmatches, mapq)\n\n#package data.table\ndt[, .(read_id, missmatches, mapq)]   #NB: .() est un alias pour \"list()\"\n\ndt[, .SD, .SDcols=c(\"read_id\", \"missmatches\", \"mapq\")] #ecriture a combiner avec lapply\n#SD pour Subset of Data: les colonnes listees seront aliasees par .SD avec la dimension .SDcols\n#et par defaut, toutes les colonnes sont traitees\n```\n:::\n\n\n<br> \\## data.table {#data.table1}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# \n```\n:::\n\n\n<br>\n\n# 5. Joindre des tables {#join}\n\n## Rbase {#Rbase2}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n # R base\nstart.time <- Sys.time()\n#df_join=base::merge(df,fadf, by=\"read_id\", all.x=TRUE)\nSys.time() - start.time\n#####Time difference of 1.373174 mins\n```\n:::\n\n\n<br> \\## tydiverse {#tidyverse2}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#suite tidyverse\nstart.time <- Sys.time()\nd_join=d%>%left_join(fa)   #NB: une seule var key commune, nul besoin de preciser la var de jointure\n#sinon: d_join=d%>%left_join(y=fa, by=\"read_id\")\nSys.time() - start.time\n```\n:::\n\n\n<br> \\## data.table avec ou sans index {#data.table2}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#package data.table\n##avec merge, meme ecriture qu'avec la fonction de R base\n\nstart.time = Sys.time()\ndt_join=merge(dt,fadt, by=\"read_id\", all.x=T)\ntime.dt_sansindex = Sys.time() - start.time\n\nstart.time = Sys.time()\ndt_join=dt[fadt, on=\"read_id\", nomatch=NULL]\nSys.time() - start.time\n\n##indexation de tables: accelere les combinaisons de donnees\nsetkey(dt, read_id)\nsetkey(fadt, read_id)\n\nstart.time = Sys.time()\ndt_join=merge(dt,fadt, by=\"read_id\", all.x=T)\ntime.dt_avecindex = Sys.time() - start.time\ntime.dt_sansindex\ntime.dt_avecindex\n\nkey(dt)\nsetkey(dt, NULL)\nkey(dt)\n```\n:::\n\n\n<br>\n\n# 6. Exporter des tables {#write}\n\n## Rbase {#Rbase3}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#R base\nstart.time <- Sys.time()\n#write.table(df_join, \"ISBP_REFSEQV2_vs_RENAN_with_FASTA.TAB\", col.names=T)\nSys.time() - start.time\n#Time difference of 1.977623 mins\n```\n:::\n\n\n<br> \\## tydiverse {#tidyverse3}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#suite tidyverse package readr\nstart.time <- Sys.time()\nwrite_tsv(d_join, \"ISBP_REFSEQV2_vs_RENAN_with_FASTA.TAB\", col_names=T)\nSys.time() - start.time  # ~20 à 30sec\n```\n:::\n\n\n<br> \\## data.table {#data.table3}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#package data.table\nstart.time <- Sys.time()\nfwrite(dt_join, \"ISBP_REFSEQV2_vs_RENAN_with_FASTA.TAB\", col.names=T)\nSys.time() - start.time  # moins de 2 secondes\n```\n:::\n\n\n<br>\n\n# 7. Importer des tables au format large {#wide}\n\n## tydiverse {#tidyverse4}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# TRANSPOSITION \nmat_join=as.matrix(dt_join)\ndim(mat_join)\nhead(mat_join, n=1)\ncolnames(mat_join)\n\ntmat_join=as.matrix(t(mat_join))\ndim(tmat_join)\nhead(tmat_join[,c(1,2,3,4,5)], n=9)\ntmat_join=data.table(tmat_join)\n\nfwrite(tmat_join, \"ISBP_REFSEQV2_vs_RENAN_with_FASTA_transposed_dt.TAB\", sep=\"\\t\", col.names=F)\n\n#package readr de la suite tidyverse\nstart.time <- Sys.time()\n#d_trans=read_tsv(\"ISBP_REFSEQV2_vs_RENAN_with_FASTA_transposed_dt.TAB\", col_names=F)\ntime.tidy <- Sys.time() - start.time ## tres tres long\n```\n:::\n\n\n<br> \\## data.table {#data.table4}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#package data.table\nstart.time <- Sys.time()\ndt_trans=fread(\"ISBP_REFSEQV2_vs_RENAN_with_FASTA_transposed_dt.TAB\", \n         nThread=4, sep=\"\\t\", header=FALSE, dec=\".\", encoding = \"UTF-8\", showProgress=TRUE)\ntime.dt <- Sys.time() - start.time\ntime.dt # ~16 secondes\ntime.tidy\n```\n:::\n\n\n<br>\n\n# 8. Formater des données {#lapply}\n\n## tydiverse {#tidyverse5}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# mutate sur une colonne avec tidyverse\nstart.time <- Sys.time()\nd_joinU=d_join %>% head(5)%>%mutate(seq=str_replace_all(seq,\"T\",\"U\"))\ntime.tidy <- Sys.time() - start.time\n\n### mutate(across) sur toutes les colonnes \ntmat_d_join=tibble(tmat_join[,1:100000])\n\nstart.time <- Sys.time()\ntmat_d_joinU=tmat_d_join %>% mutate(across(everything(), ~gsub(\"T\",\"U\",.)))\ntime.tidy <- Sys.time() - start.time\ntime.tidy\n\nhead(tmat_d_joinU[,c(1,2,3,4,5)], n=9)\n```\n:::\n\n\n<br>\n\n## data.table {#data.table5}\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# str_replace sur une colonne\nstart.time <- Sys.time()\ndt_joinU=dt_join[1:5,][,seq:=str_replace_all(seq,\"T\",\"U\")]\ntime.dt <- Sys.time() - start.time\ntime.dt\ntime.tidy\n\n### lapply .SD .SDcols sur 5 colonnes\ncols=c(\"V1\",\"V2\",\"V3\",\"V4\",\"V5\")\ntmat_dt_joinU=tmat_dt_join[,(cols):=lapply(.SD, function(x) gsub(\"T\",\"U\",as.character(x))), .SDcols=cols]\nhead(tmat_dt_joinU[,c(1,2,3,4,5)], n=9)\n\n### lapply .SD .SDcols sur toutes les colonnes \ncols=c(\"V1\",\"V2\",\"V3\",\"V4\",\"V5\")\nstart.time <- Sys.time()\ntmat_dt_joinU=lapply(tmat_dt_join, function(x) gsub(\"T\",\"U\",as.character(x)) )\ntime.dt <- Sys.time() - start.time\ntime.dt\n\nhead(tmat_dt_joinU[,c(1,2,3,4,5)], n=9)\n```\n:::\n\n\n<br>\n\n*Références [UtilitR](https://www.book.utilitr.org/datatable.html)*\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}